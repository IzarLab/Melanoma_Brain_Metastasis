import pandas as pd
import pickle
import squidpy as sq
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
import subprocess
import numpy as np

### title: calculate cell type co-occurrence and Ripley's L statistics, based on rctd cell type assignments
### author: Yiping Wang date: 03/29/2021

pats = ["MBM05_rep1_slide","MBM06_slide","MBM07_slide","MBM08_slide","MBM11_rep1_slide","MBM18_slide","MBM13_slide","MPM08_pre_slide","MPM10_slide","MPM06_slide","MBM05_rep2_slide","MBM11_rep2_slide","puck5","puck6final","puck7_20_feature_threshold","puck8_20_feature_threshold"]

datadir = '/home/ubuntu'

main_cell_types = ['B_Plasma cells','CNS cells','Endothelial cells','Epithelial cells','Myeloid cells','Stromal cells','T_NK cells','Tumor cells']

summary_map_all = {}

#download folder of rctd cell type assignment text files
proc = subprocess.Popen(['aws','s3','sync','s3://snrna-seq/MBPM/newpuckdata/rctd_mbpm_puckdata_convert_for_squidpy',datadir+'/rctd_mbpm_puckdata_convert_for_squidpy'])
proc.wait()
proc = subprocess.Popen(['mkdir',datadir+'/rctd_mbpm_puckdata_squidpy'])
proc.wait()

for pat in pats:
    #download empty pickle files, generated by the script tangram_newversion_gpu, containing anndata objects with gene expression matrices for each puck
    print(pat)
    proc = subprocess.Popen(['aws','s3','cp','s3://snrna-seq/MBPM/newpuckdata/for_tangram_gpu_run/'+pat+'_empty.pickle',datadir+'/for_tangram_gpu_run/'+pat+'_empty.pickle'])
    proc.wait()
    adata = pickle.load(open(datadir+'/for_tangram_gpu_run/'+pat+'_empty.pickle','rb'))
    proc = subprocess.Popen(['rm',datadir+'/for_tangram_gpu_run/'+pat+'_empty.pickle'])
    proc.wait()

    #add rctd cell type information to anndata objects
    #for cells that were excluded from rctd pipeline due to quality filtering, assign a dummy cell type "a"
    cell_type = []
    barcode = []
    inFI = open(datadir+'/rctd_mbpm_puckdata_convert_for_squidpy/'+pat+'_rctd_main.txt')
    inFI.readline()
    for line in inFI:
        line = line.strip()
        words = line.split('\t')
        barcode.append(words[0])
        cell_type.append(words[2])
    inFI.close()
    cell_type_adata = []
    for i in range(len(adata.obs['barcode'])):
        try:
            findidx = barcode.index(adata.obs['barcode'][i])
            cell_type_adata.append(cell_type[findidx])
        except:
            cell_type_adata.append('a')
    adata.obs['cluster'] = pd.Series(cell_type_adata, dtype="category")
    adata.obs.index = adata.obs.barcode
    for i in range(len(adata.obs['barcode'])):
        adata.obs['cluster'][i] = cell_type_adata[i]

    adata = adata[adata.obs["cluster"] != "a", :]

    #perform spatial neighbor and neighborhood enrichment calculation
    #save heatmap figure of cell type co-occurrence strength
    sq.gr.spatial_neighbors(adata, coord_type="generic")
    sq.gr.nhood_enrichment(adata, cluster_key="cluster")
    for i in range(len(adata.uns['cluster_nhood_enrichment']['zscore'])):
        for j in range(len(adata.uns['cluster_nhood_enrichment']['zscore'])):
            if np.isnan(adata.uns['cluster_nhood_enrichment']['zscore'][i][j]):
                adata.uns['cluster_nhood_enrichment']['zscore'][i][j]=0
    pp = PdfPages(datadir+'/rctd_mbpm_puckdata_squidpy/'+pat+'_rctd_main_neighborhood_enrichment.pdf')
    [fig, row_order, col_order, row_link, col_link] = sq.pl._graph.nhood_enrichment_yiping(adata, cluster_key="cluster", method="single", cmap="inferno", vmin=-50, vmax=100)
    fig = plt.gcf()
    fig.set_size_inches(11.69,8.27)
    plt.show()
    pp.savefig(fig)
    plt.close()
    pp.close()

    #save a map of interaction strengths for each puck
    summary_map = {}
    row_order.reverse()
    for i in range(len(row_order)):
        summary_map[main_cell_types[i]] = {}
        for j in range(len(col_order)):
            summary_map[main_cell_types[i]][main_cell_types[j]] = adata.uns['cluster_nhood_enrichment']['zscore'][i][j]
    summary_map_all[pat] = summary_map

    #calculate Ripley's L clustering calculation for each puck, and save figure
    pp = PdfPages(datadir+'/rctd_mbpm_puckdata_squidpy/'+pat+'_rctd_main_ripley_L.pdf')
    mode = "L"
    sq.gr.ripley(adata, cluster_key="cluster", mode=mode)
    fig = sq.pl.ripley(adata, cluster_key="cluster", mode=mode)
    fig = plt.gcf()
    fig.set_size_inches(11.69,8.27)
    plt.show()
    pp.savefig(fig)
    plt.close()
    pp.close()

#count up most frequent cell-type co-occurrences, with an interaction strength > 10, and the pucks in which they occur
summary_count = {}
summary_count_pats = {}
for pat in summary_map_all:
    for i in range(len(main_cell_types)):
        for j in range(i+1,len(main_cell_types)):
            if summary_map_all[pat][main_cell_types[i]][main_cell_types[j]]>10:
                if (main_cell_types[i]+'_'+main_cell_types[j]) not in summary_count:
                    summary_count[main_cell_types[i]+'_'+main_cell_types[j]] = 0
                    summary_count_pats[main_cell_types[i]+'_'+main_cell_types[j]] = []
                summary_count[main_cell_types[i]+'_'+main_cell_types[j]] += 1
                summary_count_pats[main_cell_types[i]+'_'+main_cell_types[j]].append(pat)

#write out table of cell-type co-occurrences, sorted by frequency
outFI = open(datadir+'/rctd_mbpm_puckdata_squidpy/rctd_mbpm_puckdata_squidpy.txt','w')
outFI.write('interaction\tfrequency\tfound in samples\n')
sorted_cell_pairs = list(summary_count.keys())
sorted_cell_pairs.sort(reverse = True, key = lambda x: summary_count[x])
for cell_pair in sorted_cell_pairs:
    outFI.write(cell_pair+'\t'+str(summary_count[cell_pair])+'\t'+','.join(summary_count_pats[cell_pair])+'\n')
outFI.close()
